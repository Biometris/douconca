% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ipfN2marginals.R
\name{ipf2N2}
\alias{ipf2N2}
\title{Iterative proportional fitting of an abundance table to Hill-N2 marginals}
\usage{
ipf2N2(
  Y,
  max_iter = 100,
  updateN2 = TRUE,
  N2N_N2_species = TRUE,
  N2N_N2_sites = FALSE,
  crit = 1e-04
)
}
\arguments{
\item{Y}{abundance table (matrix or dataframe-like).}

\item{max_iter}{maximum number of iterative proportional fitting (ipf) 
iterations.}

\item{updateN2}{logical, default \code{TRUE}.
If \code{FALSE} the marginal sums are proportional to 
the N2-marginals of the initial table, but the N2-marginals of the returned 
matrix may not be equal to their marginal sum.
If \code{updateN2 = TRUE} and \code{N2N_N2_species = FALSE},
the returned transformed table has N2 columns marginals, 
\emph{i.e.} \code{colSums(Y2) = const*N2species(Y2)} with \code{Y2} 
the return value of \code{ipf2N2} and \code{const} a constant.
If converged, N2 row marginals are also equal to the row sums, \emph{i.e.} 
\code{rowSums(Y2) = approx. N2sites(Y2)}.
If  \code{N2N_N2_species=TRUE}, the column marginals are \code{N2(N-N2)/2} 
and the row sums are proportional to, what we term, the effective number of
informative species}

\item{N2N_N2_species}{Set marginals equal to \code{N2(N-N2)} Default 
\code{TRUE}.}

\item{N2N_N2_sites}{Default \code{FALSE}. DO not change.}

\item{crit}{stopping criterion.}
}
\value{
matrix obtained after ipf to N2-marginals.
}
\description{
Function for preprocessing/transforming an abundance table
by iterative proportional fitting,  
so that the transformed table has marginals \code{N2} or \code{N2(N-N2)}
with \code{N} the number of elements in the margin.
Hill-N2 is the effective number of species. It is of intrinsic interest in
weighted averaging (CWM and SNC) as their variance is approximately 
inversely proportional to N2 (ter Braak 2019), 
and therefore of interest in \code{\link{dc_CA}}.
}
\details{
Applying \code{ipf2N2} with \code{N2N_N2_species=FALSE} 
to an presence-absence data table returns the same table.
However, a species that occurs everywhere (or in most of the sites)
is not very informative. This is acknowledged with the default option
\code{N2N_N2_species=TRUE}. Then,
with \code{N2N_N2_species=TRUE}, species that occur
in more than halve the number of sites are downweighted, so that
the row sum no longer equal to the richness of the site (the number of species),
but proportional to the number of informative species.
}
\examples{
data("dune_trait_env")

# rownames are carried forward in results
rownames(dune_trait_env$comm) <- dune_trait_env$comm$Sites
Y <- dune_trait_env$comm[, -1] # must delete "Sites"
Y_N2 <- ipf2N2(Y, updateN2 = FALSE, N2N_N2_species = FALSE)
attr(Y_N2, "iter") # 6

# show that column margins of the transform matrix are
# equal to the Hill N2 values
diff(range(colSums(Y_N2) / apply(X = Y, MARGIN = 2, FUN = fN2))) #  8.881784e-16
diff(range(rowSums(Y_N2) / apply(X = Y, MARGIN = 1, FUN = fN2))) #  0.0201

Y_N2i <- ipf2N2(Y, updateN2 = TRUE, N2N_N2_species = FALSE)
attr(Y_N2i, "iter") # 9
diff(range(colSums(Y_N2i) / apply(X = Y_N2i, MARGIN = 2, FUN = fN2))) #  1.776357e-15
diff(range(rowSums(Y_N2i) / apply(X = Y_N2i, MARGIN = 1, FUN = fN2))) #  0.0229

# the default version:
Y_N2N_N2i <- ipf2N2(Y)
# ie. 
# Y_N2N_N2i <- ipf2N2(Y, updateN2 = TRUE, N2N_N2_species = TRUE)
attr(Y_N2N_N2i, "iter") # 16
N2 <- apply(X = Y_N2N_N2i, MARGIN = 2, FUN = fN2)
N <- ncol(Y)
diff(range(colSums(Y_N2N_N2i) / (N2 * (N - N2)))) #  8.326673e-17

N2 <- apply(X = Y_N2N_N2i, MARGIN = 1, FUN = fN2)
N <- nrow(Y)
diff(range(rowSums(Y_N2N_N2i) / (N2 * (N - N2)))) #  0.207

sum(Y_N2N_N2i) - sum(Y)

mod0 <- dc_CA(formulaEnv = ~ A1 + Moist + Mag + Use + Manure,
              formulaTraits = ~ SLA + Height + LDMC + Seedmass + Lifespan,
              response = Y,  
              dataEnv = dune_trait_env$envir,
              dataTraits = dune_trait_env$traits, 
              divide = FALSE,
              verbose = FALSE)

mod1 <- dc_CA(formulaEnv = ~ A1 + Moist + Mag + Use + Manure,
              formulaTraits = ~ SLA + Height + LDMC + Seedmass + Lifespan,
              response = Y_N2N_N2i,  
              dataEnv = dune_trait_env$envir,
              dataTraits = dune_trait_env$traits, 
              divide = FALSE,
              verbose = FALSE)

mod1$eigenvalues / mod0$eigenvalues
# as the ratios of eigenvalues are greater than 1,
# all axes have higher (squared) fourth-corner correlation

Y_PA <- 1 * (Y > 0)
Y_PA_N2 <- ipf2N2(Y_PA, N2N_N2_species = FALSE)
attr(Y_PA_N2, "iter") # 1
diff(range(Y_PA - Y_PA_N2)) # 4.440892e-16

Y_PA_N2i <- ipf2N2(Y_PA, N2N_N2_species = TRUE)
attr(Y_PA_N2i, "iter") # 9
N_occ <- colSums(Y_PA) # number of occurrences of species
N <- nrow(Y_PA)
plot(N_occ, colSums(Y_PA_N2i))
cor(colSums(Y_PA_N2i), N_occ * (N - N_occ)) # 0.79
}
